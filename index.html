<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=0" charset="utf-8"/>
<html>
<head>
  <title>Tetris</title>
  <style>

    #body{
        margin: 0px 0px;
        display: flex;
        justify-content: center;
    }

    #login{
      height: 100%;
      width: 100%;
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0, 20, 47,0.9);

    }

    #form{
      z-index: 10;
      width: 20em;
      height: 22.74em;

      min-width: 10%;
      min-height: 21.2522%;

      background-size: contain;
      background-repeat: no-repeat;

      display: inline-block;
      align-items: center;
      justify-content: center;

      background-image: url(background_login.png);
    }


    #nickname{
      display: inline-block;
      height: 10vw;
      max-height: 8%;
      width: 60%;
      margin-top: 25%;
      margin-left: 15%;
      border: 0;
      border-radius: 5em;
      
      padding-left: 5%;
      padding-right: 5%;

      font-size: max(min(4vw, 13px), 1.5vw);
    }

    #email{
      display: inline-block;
      height: 10vw;
      max-height: 8%;
      width: 60%;
      margin-top: 5%;
      margin-left: 15%;
      border: 0;
      border-radius: 5em;

      padding-left: 5%;
      padding-right: 5%;

      font-size: max(min(4vw, 13px), 1.5vw);


    }

    #universidade{
      display: inline-block;
      height: 10vw;
      max-height: 8%;
      width: 60%;
      margin-top: 5%;

      margin-left: 15%;
      border: 0;
      border-radius: 5em;

      padding-left: 5%;
      padding-right: 5%;

      font-size: max(min(4vw, 13px), 1.5vw);

    }

    #checkTermsDiv{
      height: 4vw;
      max-height: 8%;

      width: 85%;
      margin-top: 5%;
      margin-bottom: 5%;
      margin-left: 15%;
      display: flex;
      align-items: center;
      justify-content: stretch;
    }

    input[type=checkbox].css-checkbox {
		  position:absolute; z-index:-1000; left:-1000px; overflow: hidden; clip: rect(0 0 0 0); height:1px; width:1px; margin:-1px; padding:0; border:0;
		}

		input[type=checkbox].css-checkbox + label.css-label {
      height: fit-content;
      max-height: 8%;
      width: 85%;

      margin-top:5%;
      margin-left: 15%;

      padding-left:12%;
      padding-bottom: 0px;

			display:inline-block;
			line-height:auto;
			background-repeat:no-repeat;
			background-position: 0 0;
      
      font-size: max(min(4vw, 13px), 1.5vw);


			vertical-align:middle;
      cursor:pointer;
		}

		input[type=checkbox].css-checkbox:checked + label.css-label {
      background-position: 0 100%;
      
    }
    
		label.css-label {
      background-image:url(checkbox.png);
      
      
      /*background-size: min(2vw, 8%);*/
      background-size: max(min(5.324vw, 17.3px), 2vw);

			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
    }
    
    a:link {
      color: white;
    }
    a:visited{
      color: white;
    }
    a:hover {
      color: gray;
    }
    a:active {
      color: rgba(0, 20, 47,0.9);
    } 

    #btnGo{
      
      display: inline-block;
      height: 15vw;
      max-height: 12%;
      margin-left: 15%;
      padding-left:0;
      margin-right: 45%;
      border: 0;
      margin-top: 5%;
      margin-bottom: 5%;
      background: transparent;
    }
    #tetris{
      height: min(100vh, 150vw);
      width: 100vw;
      max-width: 100vh;
      display: inline-block;
      text-align: justify;
      white-space: nowrap; 
      background-image: url("background_menu.png");
      background-size: 100%;
    }
      
    #menu{
      height: min(100vh, 150vw);
      width: calc(100% - 50vh);
      display: inline-block;
      background-color: rgba(255, 255, 250, 0);
    }
      
    #canvasDiv{
      height: min(100vh, 150vw);
      width: 50vh;
      max-width: min(50vh, 80vw);
      vertical-align: top;
      float: right;
    }
    
    #canvas{
      height: min(100vh, 150vw);
      width: 50vh;
      max-width: min(50vh, 80vw);
      display: inline-block;
      position: relative;
      vertical-align: top;
      background-color: rgba(0, 20, 47, 0.85);
    }

    #placar{
      height: min(20vh, min(29vw, calc(100vw - min(50vh, 80vw))));
      width: 100%;
      max-width: min(50vh, 80vw);
      float: right;
      position: relative;
      vertical-align: top;
      background-color: rgba(0, 20, 47, 0.85);

      display: flex;
      justify-content: center;
      font-size: max(min(4vw, 13px), 1.5vw);
      color: white;
    }

    #player{
      display: flex;
    }
    
    #score{
      display: flex;
    }

    #submenu{
      width: 100%;
      height: min(20vh, min(29vw, calc(100vw - min(50vh, 80vw))));
      display: inline-block;
      justify-content: center;
      text-align: center;
      background-color: rgba(255, 255, 250, 0);
    }

    #upcoming{
      height: min(20vh, min(29vw, calc(100vw - min(50vh, 80vw))));
      width: min(20vh, min(29vw, calc(100vw - min(50vh, 80vw))));
      position: relative;
      z-index: 5;
      display: inline-block;
      background-color: rgba(0, 20, 47,0.8);
    }

    #painel{
      height: 0vh;
      width: 0vw;
      max-width: 100vh;
      display: inline-block;
      text-align: justify;
      white-space: nowrap; 
      background-color: rosybrown;
      background-size: 100%;
    }

    #gameOver{
      height: 100%;
      width: 100%;
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0, 20, 47,0.9);
    }

    #gameOverText{
      font-size: max(min(8vw, 26px), 3vw);
      display: inline-block;
      color: white;
      margin-top: 15%;
      margin-left: 15%;
    }

    #desafieText{
      font-size: max(min(4vw, 13px), 1.5vw);
      display: inline-block;
      color: white;
      margin-top: 5%;
      margin-left: 15%;
      margin-right: 15%;
    }

    #btnGameOver{
      display: inline-block;
      height: 15vw;
      max-height: 12%;
      margin-left: 15%;
      padding-left:0;
      margin-right: 45%;
      border: 0;
      margin-top: 5%;
      background: transparent;
    }

    #btnWpp{
      display: inline-block;
      height: 10vw;
      width: 10vw;
      max-height: 9%;
      max-width: 9%;
      
      margin-left: 15%;
      padding-left:0;
      border: 0;
      margin-top: 5%;
      background: transparent;
    }

  </style>
</head>

<body id="body">

  <div id="login">
    <form id="form">

      <input placeholder="Nome" type="text" id="nickname" nickname="nickname" maxlength="15">
      <input placeholder="Email" type="text" id="email" email="email" maxlength="50">
      <input placeholder="Universidade" type="text" id="universidade" universidade="universidade" maxlength="15">

      <input type="checkbox" name="checkTerms" id="checkboxG1" class="css-checkbox" checked/>
      <label for="checkboxG1" class="css-label"><a color="white" href="https://tetrix.vtex.com/wp-content/uploads/2020/04/REGULAMENTO-CONCURSO-TETRIX-2020.pdf">Concordo com  os termos.</a></label>
  
      <button type="submit" id="btnGo" onclick="tryToEnter(event)">
        <img src="btn_jogar.png" id="btnImg" height="100%" width="100%"/>
      </button>

    </form>
  </div>

  <div id="tetris">

    <div id="menu">
        <div id="submenu">
            <canvas id="upcoming"></canvas>
        </div>
            
    </div>
    <div id="canvasDiv">
      <div id="placar">
        <span id="player"> </span>
        <span id="score"> </span>
      </div>
      <canvas id="canvas">
        Desculpe, seu navegador não suporta o elemento &lt;canvas&gt;
      </canvas>
    </div>

  </div>

  <div id="gameOver">
    <form id="form">

      <label id="gameOverText">VOCÊ JÁ SE INSCREVEU?</label>
      
      <button type="submit" id="btnGameOver" onclick="location.href='https://tetrix2020.typeform.com/to/R4hDEy'">
        <img src="btn_se_inscreva.png" id="btnImg" height="100%" width="100%"/>
      </button>

      <button type="submit" id="btnGameOver" onclick="tryToEnter(event)">
        <img src="btn_jogar.png" id="btnImg" height="100%" width="100%"/>
      </button>

      <label id="desafieText">DESAFIE OS SEUS AMIGOS A JOGAREM TAMBÉM!</label>

      <button id="btnWpp" type="submit" onclick="wppShare()">
        <img id="wppIcon" src="wpp_icon.png" height="100%"/>
      </button>

    </form>
  </div>

  <div id="painel">

      <div id="ranking">

  </div>


  <audio id="song" loop="loop">
    <source src="song.mp3" type="audio/mp3">
      Seu navegador não suporta elemento de áudio.
    </audio>

    <button id="btnSong" onclick="changeAudio()"></button><p></p>
    </div>
<!--
  <div id="painel">
    <p>

      </p>
      <p>
        <span>top 20<br></span>
      </p>
      <div id="ranking">
      </div>
  </div>


  <audio id="song" loop="loop">
    <source src="song.mp3" type="audio/mp3">
      Seu navegador não suporta elemento de áudio.
    </audio>

    <button id="btnSong" onclick="changeAudio()">tocar música</button><p></p>
    <div id="desafieDiv">
      <br>
      <p>
        <label id="desafieText">desafie os seus amigos a jogarem também!</label>
      </p>
      <button id="btnWpp" type="submit" onclick="wppShare()">
        <a target="_blank" href='https://pt.stackoverflow.com'></a>
        <img id="wppIcon" src="wpp_icon.png" />
     </button>
    </div>
-->
<script>


  //-------------------------------------------------------------------------
  // base helper methods
  //-------------------------------------------------------------------------

  function get(id)        { return document.getElementById(id);  }
  function hide(id)       { get(id).style.visibility = 'hidden'; }
  function show(id)       { get(id).style.visibility = null;     }
  function html(id, html) { get(id).innerHTML = html;            }

  function timestamp()           { return new Date().getTime();                             }
  function random(min, max)      { return (min + (Math.random() * (max - min)));            }
  function randomChoice(choices) { return choices[Math.round(random(0, choices.length-1))]; }

  if (!window.requestAnimationFrame) { // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimationFrame = window.webkitRequestAnimationFrame ||
                                   window.mozRequestAnimationFrame    ||
                                   window.oRequestAnimationFrame      ||
                                   window.msRequestAnimationFrame     ||
                                   function(callback, element) {
                                     window.setTimeout(callback, 1000 / 60);
                                   }
  }

  //-------------------------------------------------------------------------
  // game constants
  //-------------------------------------------------------------------------

  var KEY     = { ESC: 27, SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, ENTER: 13},
      DIR     = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3, MIN: 0, MAX: 3 },
      //stats   = new Stats(),
      canvas  = get('canvas'),
      ctx     = canvas.getContext('2d'),
      ucanvas = get('upcoming'),
      uctx    = ucanvas.getContext('2d'),
      speed   = { start: 0.6, decrement: 0.005, min: 0.1 }, // how long before piece drops by 1 row (seconds)
      nx      = 10, // width of tetris court (in blocks)
      ny      = 20, // height of tetris court (in blocks)
      nu      = 5;  // width/height of upcoming preview (in blocks)

  //-------------------------------------------------------------------------
  // game variables (initialized during reset)
  //-------------------------------------------------------------------------

  var dx, dy,        // pixel size of a single tetris block
      blocks,        // 2 dimensional array (nx*ny) representing tetris court - either empty block or occupied by a 'piece'
      actions,       // queue of user actions (inputs)
      playing,       // true|false - game is in progress
      dt,            // time since starting this game
      dtDown = 0,
      current,       // the current piece
      next,          // the next piece
      score,         // the current score
      vscore,        // the currently displayed score (it catches up to score in small chunks - like a spinning slot machine)
      rows,          // number of completed rows in the current game
      step,         // how long before current piece drops by 1 row        
      downFactor = 1,
      sideFactor = 0;

  // Dados atuais do jogador
  var nickname,
      email,
      universidade;
  // Array no servidor:
  var usersData = [];

  var songIsPlaying = false;

  function wppShare(){
    window.open('https://api.whatsapp.com/send?text=Já pensou viajar o mundo sem pagar nada? Participe do TETRIX: https://tetrix.vtex.com/');
  }

  //-------------------------------------------------------------------------
  // tetris pieces
  //
  // blocks: each element represents a rotation of the piece (0, 90, 180, 270)
  //         each element is a 16 bit integer where the 16 bits represent
  //         a 4x4 set of blocks, e.g. j.blocks[0] = 0x44C0
  //
  //             0100 = 0x4 << 3 = 0x4000
  //             0100 = 0x4 << 2 = 0x0400
  //             1100 = 0xC << 1 = 0x00C0
  //             0000 = 0x0 << 0 = 0x0000
  //                               ------
  //                               0x44C0
  //
  //-------------------------------------------------------------------------

  var i = { size: 4, blocks: [0x0F00, 0x2222, 0x00F0, 0x4444]};
  var j = { size: 3, blocks: [0x44C0, 0x8E00, 0x6440, 0x0E20]};
  var l = { size: 3, blocks: [0x4460, 0x0E80, 0xC440, 0x2E00]};
  var o = { size: 2, blocks: [0xCC00, 0xCC00, 0xCC00, 0xCC00]};
  var s = { size: 3, blocks: [0x06C0, 0x8C40, 0x6C00, 0x4620]};
  var t = { size: 3, blocks: [0x0E40, 0x4C40, 0x4E00, 0x4640]};
  var z = { size: 3, blocks: [0x0C60, 0x4C80, 0xC600, 0x2640]};

  //------------------------------------------------
  // do the bit manipulation and iterate through each
  // occupied block (x,y) for a given piece
  //------------------------------------------------
  function eachblock(type, x, y, dir, fn) {
    var bit, result, row = 0, col = 0, blocks = type.blocks[dir];
    for(bit = 0x8000 ; bit > 0 ; bit = bit >> 1) {
      if (blocks & bit) {
        fn(x + col, y + row);
      }
      if (++col === 4) {
        col = 0;
        ++row;
      }
    }
  }

  //-----------------------------------------------------
  // check if a piece can fit into a position in the grid
  //-----------------------------------------------------
  function occupied(type, x, y, dir) {
    var result = false
    eachblock(type, x, y, dir, function(x, y) {
      if ((x < 0) || (x >= nx) || (y < 0) || (y >= ny) || getBlock(x,y))
        result = true;
    });
    return result;
  }

  function unoccupied(type, x, y, dir) {
    return !occupied(type, x, y, dir);
  }

  //-----------------------------------------
  // start with 4 instances of each piece and
  // pick randomly until the 'bag is empty'
  //-----------------------------------------
  var pieces = [];
  function randomPiece() {
    if (pieces.length == 0)
      pieces = [i,i,i,i,j,j,j,j,l,l,l,l,o,o,o,o,s,s,s,s,t,t,t,t,z,z,z,z];
    var type = pieces.splice(random(0, pieces.length-1), 1)[0];
    return { type: type, dir: DIR.UP, x: Math.round(random(0, nx - type.size)), y: 0 };
  }


  //-------------------------------------------------------------------------
  // GAME LOOP
  //-------------------------------------------------------------------------

  async function run() {

    //showStats(); // initialize FPS counter
    addEvents(); // attach keydown and resize events

    var last = now = timestamp();
    function frame() {
      now = timestamp();
      update(Math.min(1, (now - last) / 1000.0)); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab
      draw();
      last = now;
      requestAnimationFrame(frame, canvas);
    }

    resize(); // setup all our sizing information
    reset();  // reset the per-game variables
    frame();  // start the first frame

    await fetchScore()
  }

  function swipedetect(el, callback){

    var touchsurface = el,
    swipedir,
    startX,
    startY,
    distX,
    distY,
    threshold = 40, //required min distance traveled to be considered swipe
    restraint = 125, // maximum distance allowed at the same time in perpendicular direction
    allowedTime = 300, // maximum time allowed to travel that distance
    elapsedTime,
    startTime,
    handleswipe = callback || function(swipedir){}

    touchsurface.addEventListener('touchstart', function(e){
      var touchobj = e.changedTouches[0]
      swipedir = 'none'
      dist = 0
      startX = touchobj.pageX
      startY = touchobj.pageY
      startTime = new Date().getTime() // record time when finger first makes contact with surface
      e.preventDefault()
    }, false)

    touchsurface.addEventListener('touchmove', function(e){
      e.preventDefault() // prevent scrolling when inside DIV
      var touchobj = e.changedTouches[0]

    }, false)

    touchsurface.addEventListener('touchend', function(e){
      //sideFactor = 0;
      var touchobj = e.changedTouches[0];
      distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
      distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
      elapsedTime = new Date().getTime() - startTime; // get time elapsed
      if (elapsedTime <= allowedTime){ // first condition for awipe met
          //if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint){ // 2nd condition for horizontal swipe met
          //    swipedir = (distX < 0)? 'left' : 'right' // if dist traveled is negative, it indicates left swipe
          //}
          //else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint){ // 2nd condition for vertical swipe met
          
          if (sideFactor == 0 && Math.abs(distY) <= restraint){
            sideFactor = parseInt(8*distX/touchobj.target.width);
            if(Math.abs(sideFactor) >= 5){
              sideFactor = 3*sideFactor/Math.abs(sideFactor);
            }
            else if (Math.abs(sideFactor) >= 3){
              sideFactor = 2*sideFactor/Math.abs(sideFactor);
            }
            else if (Math.abs(sideFactor) >= 1){
              sideFactor = sideFactor/Math.abs(sideFactor);
            }
            else{
              sideFactor = 0;
            }

          }
          
          if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint){ // 2nd condition for vertical swipe met
              if (distY < 0){
                swipedir = 'up';
              }
              else{
                swipedir = 'down';
                if (distY >= threshold){
                  downFactor = 2;
                }
                else{
                  downFactor = 1;
                }
              }
          }

      }
      handleswipe(swipedir)
      e.preventDefault()
    }, false)
  }

  function addEvents() {
    document.addEventListener('keydown', keydown, false);
    var el = document.getElementById('canvas');
      swipedetect(el, function(swipedir){
        switch(swipedir) {
          case "left":  move(DIR.LEFT);  break;
          case "right": move(DIR.RIGHT); break;
          case "up":    rotate();        break;
          case "down":  drop();          break;
        }
      });
    window.addEventListener('resize', resize, false);
  }

  function resize(event) {
    canvas.width   = canvas.clientWidth;  // set canvas logical size equal to its physical size
    canvas.height  = canvas.clientHeight; // (ditto)
    ucanvas.width  = ucanvas.clientWidth;
    ucanvas.height = ucanvas.clientHeight;
    dx = canvas.width  / nx; // pixel size of a single tetris block
    dy = canvas.height / ny; // (ditto)
    invalidate();
    invalidateNext();
  }

  function keydown(ev) {
    var handled = false;
    if (playing) {
      switch(ev.keyCode) {
        case KEY.LEFT:   actions.push(DIR.LEFT);  handled = true; break;
        case KEY.RIGHT:  actions.push(DIR.RIGHT); handled = true; break;
        case KEY.UP:     actions.push(DIR.UP);    handled = true; break;
        case KEY.DOWN:   actions.push(DIR.DOWN);  handled = true; break;
        case KEY.ESC:    lose();                  handled = true; break;
      }
    }
    else if (ev.keyCode == KEY.ENTER){
      tryToEnter(ev);
      handled = true;
    }

      // Verificar se existe esse nome
      //    Se existe nome, validar se senha está correta
      //        Se senha estiver errada, informar e solicitar senha novamente
      //    Se não existe nome, criar novo usuário


    if (handled)
      ev.preventDefault(); // prevent arrow keys from scrolling the page (supported in IE9+ and all other browsers)
  }

  function updateRanking(){
    //let ordered = usersData.sort((a,b) => (a.score < b.score) ? 1 : ((b.score < a.score) ? -1 : 0));

    let lista = document.getElementById('ranking');
    let first = lista.firstElementChild; 
    while (first) { 
      first.remove(); 
      first = lista.firstElementChild; 
    } 
    for(var i = 0; i < 20 && i < usersData.length; i++){
      let item = document.createElement('p');

      let item_span_uni = document.createElement('span');
      item_span_uni.style = "width: 30%; display: inline-block; text-align: center;";

      let item_span_player = document.createElement('span');
      item_span_player.style = "width: 30%; display: inline-block; text-align: center;";
      
      let item_span_score = document.createElement('span');
      item_span_score.style = "width: 30%; display: inline-block; text-align: center;";

      item_span_uni.textContent = usersData[i].universidade;
      item_span_player.textContent = usersData[i].nick;
      item_span_score.textContent = usersData[i].score;

      item.appendChild(item_span_player);
      item.appendChild(item_span_uni);
      item.appendChild(item_span_score);
      lista.appendChild(item);
    }

  }

  function checkPassword(user, email) {
    return fetch('https://tetrix--storecomponents.myvtex.com/_v/tetrix/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        user: user,
        email: email,
        universidade: universidade
      }),
    });
  }

  async function fetchScore() {
    const score = await (await fetch('https://tetrix--storecomponents.myvtex.com/_v/tetrix/score')).json();

    usersData = Object.keys(score).map(key => {
      return {
      universidade: score[key].universidade,
      nick: score[key].user,
      score: score[key].score
    }});
    updateRanking()
  }

  async function saveScore(universidade, nickname, email, score) {
    const resp = await fetch('https://tetrix--storecomponents.myvtex.com/_v/tetrix/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        user: nickname,
        email: email,
        score: score,
        universidade: universidade
      }),
    });

    if (resp.status != 200) {
      alert('There was an error on sending this score.')
    }
  }

  async function tryToEnter(ev){
    ev.preventDefault()

    nickname = document.getElementById("nickname").value;
    email = document.getElementById("email").value.toLowerCase();
    universidade = document.getElementById("universidade").value;

    check = document.getElementById("checkboxG1").checked;
    if(nickname == ""){
      alert("Enter your nickname");
      return;
    }
    else if(email == ""){
      alert("Enter your e-mail");
      return;
    }
    else if (check == false){
      alert("You need to accept the terms");
      return;
    }

    const resp = await checkPassword(nickname, email);
    await fetchScore()

    if (resp.status == 200){
      if (usersData.find(user => user.nick === nickname) === undefined) {
        usersData.push({universidade: universidade, nick: nickname, email: email, score: 0})
        updateRanking()
      }
      var player_name = document.getElementById('player');
      player_name.innerHTML = nickname;
      ev.preventDefault();
      play();
    }
    else {
      const error = await resp.json()
      alert(error.message);
    }
  }

  var song = document.getElementById("song");
  var btnSong = document.getElementById("btnSong");

  function changeAudio() {
    if(songIsPlaying){
      song.pause();
      songIsPlaying = false;
      btnSong.innerHTML = 'tocar música';
    }
    else{
      song.play();
      song.volume = 0.3;
      songIsPlaying = true;
      btnSong.innerHTML = 'parar música';
    }
  }

  function pauseAudio() {
    song.pause();
    songIsPlaying = false;
    btnSong.innerHTML = 'tocar música';
  }

  function playAudio() {
    song.play();
    song.volume = 0.3;
    songIsPlaying = true;
    btnSong.innerHTML = 'parar música';
  }

  //-------------------------------------------------------------------------
  // GAME LOGIC
  //-------------------------------------------------------------------------

  async function saveFinalScore(){
    await saveScore(universidade, nickname, email, score)
    await fetchScore()
    setVisualScore();
  }

  function saveIntermediaryScore() {
    const user = usersData.find(x => x.nick === nickname)
    if(score > user.score){
      user.score = score
      updateRanking()
    }
  }

  function play() {
    hide('login');
    hide('gameOver');
    //show('howToText');
    reset();

    let body_element = document.getElementById('body');
    body_element.style = "background-color: white;";

    //let howToDiv_element = document.getElementById('howToDiv');
    //howToDiv_element.style = "background-color: white;";

    playing = true;
    playAudio();
  }
  function lose() {
    saveFinalScore();
    //hide('howToText');
    show('gameOver');
    
    let body_element = document.getElementById('body');
    body_element.style = "background-color: rgba(0, 20, 47,0.9);";

    //let howToDiv_element = document.getElementById('howToDiv');
    //howToDiv_element.style = "background-color: rgba(0, 20, 47,0.9);";

    playing = false;
    pauseAudio();
  }

  function setVisualScore(n)      { vscore = n || score; invalidateScore(); }
  function setScore(n)            { score = n; setVisualScore(n);  }
  function addScore(n)            { score = score + n; saveIntermediaryScore(); updateRanking(); }
  function clearScore()           { setScore(0); }
  function clearRows()            { setRows(0); }
  function setRows(n)             { rows = n; step = Math.max(speed.min, speed.start - (speed.decrement*rows)); invalidateRows(); }
  function addRows(n)             { setRows(rows + n); }
  function getBlock(x,y)          { return (blocks && blocks[x] ? blocks[x][y] : null); }
  function setBlock(x,y,type)     { blocks[x] = blocks[x] || []; blocks[x][y] = type; invalidate(); }
  function clearBlocks()          { blocks = []; invalidate(); }
  function clearActions()         { actions = []; }
  function setCurrentPiece(piece) { current = piece || randomPiece(); invalidate();     }
  function setNextPiece(piece)    { next    = piece || randomPiece(); invalidateNext(); }

  function reset() {
    dt = 0;
    clearActions();
    clearBlocks();
    clearRows();
    clearScore();
    setCurrentPiece(next);
    setNextPiece();
  }

  function update(idt) {
    if (playing) {
      if (vscore < score)
        setVisualScore(vscore + 1);
      handle(actions.shift());
      dt = dt + idt;
      dtDown = dtDown + idt;
      if (downFactor == 1 && dt > step) {
        dt = dt - step;
        drop();
      }
      else if (downFactor > 1) {
        drop();
      }
      if(sideFactor >= 1){
        move(DIR.RIGHT);
        sideFactor -= 1;
      }
      else if(sideFactor <= -1){
        move(DIR.LEFT);
        sideFactor += 1;
      }
    }
  }

  function handle(action) {
    switch(action) {
      case DIR.LEFT:  move(DIR.LEFT);  break;
      case DIR.RIGHT: move(DIR.RIGHT); break;
      case DIR.UP:    rotate();        break;
      case DIR.DOWN:  drop();          break;
    }
  }

  function move(dir) {
    var x = current.x, y = current.y;
    switch(dir) {
      case DIR.RIGHT: x = x + 1; break;
      case DIR.LEFT:  x = x - 1; break;
      case DIR.DOWN:  y = y + 1;  break;

    }

    if (unoccupied(current.type, x, y, current.dir)) {
      current.x = x;
      current.y = y;

      invalidate();
      return true;
    }
    else {
      return false;
    }
  }

  function rotate() {
    var newdir = (current.dir == DIR.MAX ? DIR.MIN : current.dir + 1);
    if (unoccupied(current.type, current.x, current.y, newdir)) {
      current.dir = newdir;
      invalidate();
    }
  }

  function drop() {
    
    if (!move(DIR.DOWN)) {
      downFactor = 1;
      sideFactor = 0;
      addScore(10);
      dropPiece();
      removeLines();
      setCurrentPiece(next);
      setNextPiece(randomPiece());
      clearActions();
      if (occupied(current.type, current.x, current.y, current.dir)) {
        lose();
      }
    }
  }

  function dropPiece() {
    eachblock(current.type, current.x, current.y, current.dir, function(x, y) {
      setBlock(x, y, current.type);
    });
  }

  function removeLines() {
    var x, y, complete, n = 0;
    for(y = ny ; y > 0 ; --y) {
      complete = true;
      for(x = 0 ; x < nx ; ++x) {
        if (!getBlock(x, y))
          complete = false;
      }
      if (complete) {
        removeLine(y);
        y = y + 1; // recheck same line
        n++;
      }
    }
    if (n > 0) {
      addRows(n);
      addScore(100*Math.pow(2,n-1)); // 1: 100, 2: 200, 3: 400, 4: 800
    }
  }

  function removeLine(n) {
    var x, y;
    for(y = n ; y >= 0 ; --y) {
      for(x = 0 ; x < nx ; ++x)
        setBlock(x, y, (y == 0) ? null : getBlock(x, y-1));
    }
  }

  //-------------------------------------------------------------------------
  // RENDERING
  //-------------------------------------------------------------------------

  var invalid = {};

  function invalidate()         { invalid.court  = true; }
  function invalidateNext()     { invalid.next   = true; }
  function invalidateScore()    { invalid.score  = true; }
  function invalidateRows()     { invalid.rows   = true; }

  function draw() {
    ctx.save();
    ctx.lineWidth = 1;
    ctx.translate(0.5, 0.5); // for crisp 1px black lines
    drawCourt();
    drawNext();
    drawScore();
    //drawRows();
    ctx.restore();
  }

  function drawCourt() {
    if (invalid.court) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (playing)
        drawPiece(ctx, current.type, current.x, current.y, current.dir, 1);
      var x, y, block;
      for(y = 0 ; y < ny ; y++) {
        for (x = 0 ; x < nx ; x++) {
          if (block = getBlock(x,y))
            drawBlock(ctx, x, y, block.color, 1);
        }
      }
      ctx.strokeRect(0, 0, nx*dx - 1, ny*dy - 1); // court boundary
      invalid.court = false;
    }
  }

  function drawNext() {
    if (invalid.next) {
      var padding = (nu - next.type.size) / 2; // half-arsed attempt at centering next piece display
      uctx.save();
      uctx.translate(0.5, 0.5);
      uctx.clearRect(0, 0, nu*dx, nu*dy);
      console.log(document.getElementById('upcoming').width);
      drawPiece(uctx, next.type, padding, padding, next.dir, 2*dx/document.getElementById('upcoming').width);
      uctx.strokeStyle = 'rgb(0, 20, 47)';
      uctx.strokeRect(0, 0, nu*dx - 1, nu*dy - 1);
      uctx.restore();
      invalid.next = false;
    }
  }

  function drawScore() {
    if (invalid.score) {
      html('score', ("00000" + Math.floor(vscore)).slice(-5));
      invalid.score = false;
    }
  }

  function drawRows() {
    if (invalid.rows) {
      html('rows', rows);
      invalid.rows = false;
    }
  }

  function drawPiece(ctx, type, x, y, dir, fator) {
    eachblock(type, x, y, dir, function(x, y) {
      drawBlock(ctx, x, y, type.color, fator);
    });
  }

  function drawBlock(ctx, x, y, color, fator) {
    ctx.fillStyle = 'rgb(248, 24, 97)';
    if (fator != 1)
      ctx.fillRect(0.8*dy+fator*x*dx, 0.8*dy+fator*y*dy, fator*dx*0.95, fator*dy*0.95);
    else
      ctx.fillRect(fator*x*dx, fator*y*dy, fator*dx*0.95, fator*dy*0.95);

    //ctx.strokeRect(x*dx, y*dy, dx, dy)
  }

  //-------------------------------------------------------------------------
  // FINALLY, lets run the game
  //-------------------------------------------------------------------------

  //hide('howToText');
  hide('gameOver');
  run();

</script>

</body>
</html>
